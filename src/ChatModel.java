import java.beans.PropertyChangeListener;import java.beans.PropertyChangeSupport;import java.util.concurrent.Executor;import java.util.concurrent.Executors;/**
 * The model for the MVC pattern.
 */
public class ChatModel {	private static final Executor exec = Executors.newCachedThreadPool();	private static volatile String server_message; 	private static volatile String client_message;	private Runnable s_reader;		protected PropertyChangeSupport propertyChangeSupport;		// Register this class for property change listener	public void addPropertyChangeListener(PropertyChangeListener listener) {        propertyChangeSupport.addPropertyChangeListener(listener);    }	public ChatModel() {		propertyChangeSupport = new PropertyChangeSupport(this);		s_reader = new SocketReader(this);		exec.execute(s_reader);	}	/**	 * This method runs when server sends a new message to client(s)	 * It fire a property change and notify ChatView to update the view	 * 	 */	public void getServerMessage() {		String new_message = null;		String prev_message = null;		try {			while (server_message == null) { // load new message from server				Thread.sleep(100); // Sleep for 100ms so that the other thread can update			} 			new_message = server_message;			server_message = null; // Users got the message, so clear the server message		} catch (InterruptedException e) {}		// Tell ChatView to print the new message from server		propertyChangeSupport.firePropertyChange(ChatController.CONVERSATION_PROPERTY, prev_message, new_message);	}
	public void setServerMessage(String m) {		if (m != null)			server_message = m;	}	public String getClientMessage() {		return client_message;	}	public void setClientMessage(String m) {		if (m != null)			client_message = m;	}	public void sendToServer() {		((SocketReader)s_reader).setSendMessage(true); // There is a message to send to the server	}
}
